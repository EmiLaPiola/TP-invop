
import sys
from itertools import product
import cplex

TOLERANCE = 1e-6

# ESTE SERIA EL MODELO MODIFICADO 
# Para correr el TSP comun corremos este pero fijamos las variables de los repartidores en cero.
 
class InstanciaRecorridoMixto:
    def __init__(self):
        self.cantidad_clientes = 0
        self.costo_repartidor = 0
        self.d_max = 0
        self.refrigerados = []
        self.exclusivos = []
        self.distancias = []
        self.costos = []

    def leer_datos(self, filename):
        with open(filename) as f:
            self.cantidad_clientes = int(f.readline())
            self.costo_repartidor = int(f.readline())
            self.d_max = int(f.readline())

            self.distancias = [[1000000 for _ in range(self.cantidad_clientes)] for _ in range(self.cantidad_clientes)]
            self.costos = [[1000000 for _ in range(self.cantidad_clientes)] for _ in range(self.cantidad_clientes)]

            cantidad_refrigerados = int(f.readline())
            self.refrigerados = [int(f.readline()) - 1 for _ in range(cantidad_refrigerados)]

            cantidad_exclusivos = int(f.readline())
            self.exclusivos = [int(f.readline()) - 1 for _ in range(cantidad_exclusivos)]

            for linea in f:
                i, j, d, c = map(int, linea.strip().split())
                self.distancias[i - 1][j - 1] = d
                self.distancias[j - 1][i - 1] = d
                self.costos[i - 1][j - 1] = c
                self.costos[j - 1][i - 1] = c

def cargar_instancia():
    nombre_archivo = sys.argv[1].strip()
    instancia = InstanciaRecorridoMixto()
    instancia.leer_datos(nombre_archivo)
    return instancia


    # Las variables que tenemos son 
    # x_ij 
    # xi 
    # δij 
    # δi
    # ui 
    # z_i

    # variables x_ij: si el camión va de i a j

def agregar_variables(prob, instancia):
    n = instancia.cantidad_clientes
    xij, xi, dij, di, ui = [], [], [], [], []

    nombres, costos, tipos = [], [], []

    for i in range(n):
        for j in range(n):
            if i != j:
                nombres.append(f"x_{i}_{j}")
                costos.append(instancia.costos[i][j])
                tipos.append("B")
                xij.append((i, j))

    for i in range(n):
        nombres.append(f"x_{i}")
        costos.append(0)
        tipos.append("B")
        xi.append(i)

    for i in range(n):
        for j in range(n):
            if i != j:
                nombres.append(f"delta_{i}_{j}")
                costos.append(0)
                tipos.append("B")
                dij.append((i, j))

    for i in range(n):
        nombres.append(f"delta_{i}")
        costos.append(instancia.costo_repartidor)
        tipos.append("B")
        di.append(i)

    for i in range(n):
        nombres.append(f"u_{i}")
        costos.append(0)
        tipos.append("I")
        ui.append(i)

    prob.variables.add(obj=costos, types=tipos, names=nombres)
    

   # RESTRICCIONES : 
    
    # 1) cada cliente debe ser atendido solo una vez 
    # 2) El camiión debe entrar y salir solo una vez de las casas que si visita.
    # 3) Relacion entre las casa a las que llegan y las que salen repartidores
    # 4) Límite de distancia para repartidores
    # 5) Restricciones de productos refrigerados por repartidor
    # 6) Restricciones de eliminación de subtours (MTZ modificadas)
    
    
    # RESTRICCIONES DESEABLES : 
    # 7)  MÍnimo de pedidos por repartidor activo
    # 8)  Clientes obligatorios con camion.  
    
    

    # 1) cada cliente debe ser atendido solo una vez  
    # EXCLUIMOS el nodo 0 (depósito) 
    


def agregar_restricciones(prob, instancia):
    n = instancia.cantidad_clientes
    restricciones, sentidos, rhs, nombres = [], [], [], []

    # 1. Cada cliente atendido una única vez
    for i in range(n):
        restricciones.append([[f"x_{i}", f"delta_{i}"], [1.0, 1.0]])
        sentidos.append("E")
        rhs.append(1.0)
        nombres.append(f"atencion_unica_{i}")

    # 2. Entrada y salida del camión por nodo visitado
    for i in range(n):
        salida = [f"x_{i}_{j}" for j in range(n) if j != i]
        entrada = [f"x_{j}_{i}" for j in range(n) if j != i]
        restricciones.append([salida, [1.0]*len(salida)])
        sentidos.append("E")
        rhs.append(1.0)
        nombres.append(f"salida_camion_{i}")

        restricciones.append([entrada, [1.0]*len(entrada)])
        sentidos.append("E")
        rhs.append(1.0)
        nombres.append(f"entrada_camion_{i}")

    # 3. Relación delta_{ij} con delta_j
    for j in range(n):
        indices = [f"delta_{i}_{j}" for i in range(n) if i != j]
        restricciones.append([indices + [f"delta_{j}"], [1.0]*len(indices) + [-1.0]])
        sentidos.append("E")
        rhs.append(0.0)
        nombres.append(f"relacion_delta_{j}")

    # 4. Distancia máxima del repartidor
    for i, j in product(range(n), repeat=2):
        if i != j:
            restricciones.append([[f"delta_{i}_{j}", f"x_{i}"], [instancia.distancias[i][j], -instancia.d_max]])
            sentidos.append("L")
            rhs.append(0.0)
            nombres.append(f"dist_max_{i}_{j}")

    # 5. Productos refrigerados (solo uno por repartidor)
    for i in range(n):
        indices = [f"delta_{i}_{j}" for j in instancia.refrigerados if j != i]
        restricciones.append([indices, [1.0]*len(indices)])
        sentidos.append("L")
        rhs.append(1.0)
        nombres.append(f"refrigerado_{i}")

    # 6. Subtours - MTZ
    for i in range(1, n):
        restricciones.append([[f"u_{i}"], [1.0]])
        sentidos.append("G")
        rhs.append(1.0)
        nombres.append(f"ui_lb_{i}")

        restricciones.append([[f"u_{i}", f"x_{i}"], [1.0, -n]])
        sentidos.append("L")
        rhs.append(0.0)
        nombres.append(f"ui_ub_{i}")

    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                restricciones.append([[f"u_{i}", f"u_{j}", f"x_{i}_{j}"], [1.0, -1.0, n]])
                sentidos.append("L")
                rhs.append(n - 1)
                nombres.append(f"mtz_{i}_{j}")

    # 7. Exclusivos: deben ser visitados por el camión
    for i in instancia.exclusivos:
        restricciones.append([[f"x_{i}"], [1.0]])
        sentidos.append("E")
        rhs.append(1.0)
        nombres.append(f"exclusivo_{i}")

    # 8. El camión debe salir y volver al nodo 0
    restricciones.append([[f"x_0_{j}" for j in range(1, n)], [1.0]*(n-1)])
    sentidos.append("E")
    rhs.append(1.0)
    nombres.append("salida_deposito")

    restricciones.append([[f"x_{j}_0" for j in range(1, n)], [1.0]*(n-1)])
    sentidos.append("E")
    rhs.append(1.0)
    nombres.append("entrada_deposito")

    prob.linear_constraints.add(lin_expr=[cplex.SparsePair(ind=ind, val=val) for ind, val in restricciones],
                                senses=sentidos, rhs=rhs, names=nombres)

def armar_lp(prob, instancia):
    agregar_variables(prob, instancia)
    agregar_restricciones(prob, instancia)
    prob.objective.set_sense(prob.objective.sense.minimize)
    prob.write("modelo.lp")

def resolver_lp(prob):
    prob.parameters.timelimit.set(60)
    prob.parameters.mip.tolerances.mipgap.set(0.01)
    print("Resolviendo el modelo...")
    prob.solve()

def mostrar_solucion(prob, instancia):
    status = prob.solution.get_status_string()
    print("Estado de la resolución:", status)
    valor_obj = prob.solution.get_objective_value()
    print("Valor de la función objetivo:", valor_obj)

    for var_name, var_value in zip(prob.variables.get_names(), prob.solution.get_values()):
        if var_value > TOLERANCE:
            print(f"{var_name} = {var_value}")

def main():
    instancia = cargar_instancia()
    prob = cplex.Cplex()
    armar_lp(prob, instancia)
    resolver_lp(prob)
    mostrar_solucion(prob, instancia)

if __name__ == "__main__":
    main()
